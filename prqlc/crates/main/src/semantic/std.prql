# The PRQL standard library defines the following functions and transforms.
# The definitions are whitespace insensitive, and have this form:
#
# ```
# let my_func = param1 param2 ...  -> <return_type> body_expr
# ```
#
# Where:
#   * `my_func` is the name of the function
#   * `param1` is the first parameter optionally followed by a type in "< ... >"
#   * `param2` etc. follow the same pattern as param1
#   * `<return_type>` is the type of result wrapped in "< ... >"
#   * `body_expr` defines the function body that creates the result.
#     It can be PRQL code or `internal ...` to indicate internal compiler code.

# Types

## Type primitives
type int
type float
type bool
type text
type date
type time
type timestamp
type `func`
type any

# Operators

let or = func left<bool> right<bool> -> <bool> internal std.or
let mul = func left right -> <int || float> internal std.mul
let div_i = func left right -> <int || float> internal std.div_i
let div_f = func left right -> <int || float> internal std.div_f
let mod = func left right -> <int || float> internal std.mod
let add = func left<int || float || timestamp || date> right<int || float || timestamp || date> -> <int || float || timestamp || date> internal std.add
let sub = func left<int || float || timestamp || date> right<int || float || timestamp || date> -> <int || float || timestamp || date> internal std.sub
let eq = func left right -> <bool> internal std.eq
let ne = func left right -> <bool> internal std.ne
let gt = func left right -> <bool> internal std.gt
let lt = func left right -> <bool> internal std.lt
let gte = func left right -> <bool> internal std.gte
let lte = func left right -> <bool> internal std.lte
let and = func left<bool> right<bool> -> <bool> internal std.and
let coalesce = func left right -> internal std.coalesce
let regex_search = func text pattern -> <bool> internal std.regex_search

let neg = expr<int || float> -> <int || float> internal std.neg
let not = expr<bool> -> <bool> internal std.not

## Generic array
type array = [any]

## Scalar
type scalar = int || float || bool || text || date || time || timestamp || null

## Tuple of possibly many types
type tuple = {any..}

## Range
type range = {start = scalar, end = scalar}

## Relation (an array of tuples)
type relation = [tuple]

## Columnar relation (a tuple of arrays)
type tuple_of_arrays = {array..}

## Transform
type transform = (func relation -> relation)

# Functions

## Relational transforms
let from = func
  source <relation>
  -> <relation> source

@(implicit_closure on:0 param_names:[this])
let select = func
  columns <tuple>
  tbl <relation>
  -> <relation> internal select

@(implicit_closure on:0 param_names:[this])
let filter = func
  condition <bool>
  tbl <relation>
  -> <relation> internal filter

@(implicit_closure on:0 param_names:[this])
let derive = func
  columns <tuple>
  tbl <relation>
  -> <relation> internal derive

@(implicit_closure on:0 param_names:[this])
let aggregate = func
  columns <tuple>
  tbl <relation>
  -> <relation> internal aggregate

@(implicit_closure on:0 param_names:[this])
let sort = func
  by <tuple>
  tbl <relation>
  -> <relation> internal sort

let take = func
  expr <scalar>
  tbl <relation>
  -> <relation> internal take

@(implicit_closure on:1 param_names:[this, that])
let join = func
  right <relation>
  condition <bool>
  `noresolve.side`:inner
  left <relation>
  -> <relation> internal join

@(implicit_closure on:0 param_names:[this])
let group = func
  by<scalar || tuple>
  pipeline <transform>
  tbl <relation>
  -> <relation> internal group

@(implicit_closure on:0 param_names:[this])
let window = func
  rows:0..0
  range:0..0
  expanding <bool>:false
  rolling <int>:0
  expr <tuple>
  tbl <relation>
  -> <relation> internal window

let append = bottom<relation> top<relation> -> <relation> internal append
# let intersect = bottom<relation> top<relation> -> <relation> (
#   top
#   join bottom (tuple_every (tuple_map _eq (tuple_zip this that)))
#   select this.top
# )
# let remove = bottom<relation> top<relation> -> <relation> (
#   top
#   join side:left (b = bottom) (tuple_every (tuple_map _eq (tuple_zip this that)))
#   filter (tuple_every (tuple_map _is_null b.*))
#   select this.top
# )
let loop = func
  pipeline <transform>
  top <relation>
  -> <relation> internal loop

## Aggregate functions
# These return either a scalar when used within `aggregate`, or a column when used anywhere else.

let min = column <array> -> <int || float || null> internal std.min

let max = column <array> -> <int || float || null> internal std.max

let sum = column <array> -> <int || float> internal std.sum

let average = column <array> -> <float || null> internal std.average

let stddev = column <array> -> <float || null> internal std.stddev

let all = column <array> -> <bool> internal std.all

let some = column <array> -> <bool> internal std.some

let concat_array = column <array> -> <text> internal std.concat_array

# Counts number of items in the column.
# Note that the count will include null values.
let count = column<array> -> <int> internal std.count

# Deprecated in favour of filterning input to the [std.count] function (not yet implemented).
@deprecated
let count_distinct = column <array> -> internal std.count_distinct

## Window functions
let lag =   offset <int>    column <array> -> internal std.lag
let lead =  offset <int>    column <array> -> internal std.lead
let first      = column <array> -> internal std.first
let last       = column <array> -> internal std.last
let rank       = column <array> -> internal std.rank
let rank_dense = column <array> -> internal std.rank_dense
let row_number = column <array> -> internal std.row_number

## Misc functions
let round = n_digits column -> <scalar> internal std.round
let as = `noresolve.type` column -> <scalar> internal std.as
let in = pattern value -> <bool> internal in

## Tuple functions
let tuple_every = func list -> <bool> internal tuple_every
let tuple_map = func fn <func> list -> internal tuple_map
let tuple_zip = func a b -> internal tuple_zip
let _eq = func a -> internal _eq
let _is_null = func a -> _param.a == null
let tuple_exclude = func tuple except -> internal tuple_exclude

## Misc
let from_text = input<text> `noresolve.format`:csv -> <relation> internal from_text

## String functions
let lower = column -> <text> internal std.lower
let upper = column -> <text> internal std.upper

## File-reading functions, primarily for DuckDB
let read_parquet = source<text> -> <relation> internal std.read_parquet
let read_csv = source<text> -> <relation> internal std.read_csv
